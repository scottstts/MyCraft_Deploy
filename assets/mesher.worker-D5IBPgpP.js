(function(){"use strict";function dt(n){return n&&n.type==="MESH_CHUNK"&&n.payload&&typeof n.payload.key=="string"&&n.payload.chunkData&&n.payload.atlasConfig&&Array.isArray(n.payload.blockRegistry)}const e={x:48,y:96,z:48};function m(n,t,o){return t*(e.x*e.z)+o*e.x+n}let k=new Map,q=null;const pt=[{name:"front",dir:[0,0,1],normal:[0,0,1]},{name:"back",dir:[0,0,-1],normal:[0,0,-1]},{name:"right",dir:[1,0,0],normal:[1,0,0]},{name:"left",dir:[-1,0,0],normal:[-1,0,0]},{name:"top",dir:[0,1,0],normal:[0,1,0]},{name:"bottom",dir:[0,-1,0],normal:[0,-1,0]}];self.onmessage=n=>{const t=n.data;dt(t)?mt(t):console.warn("[MesherWorker] Unknown request type:",t)};function mt(n){const{key:t,chunkData:o,atlasConfig:s,blockRegistry:c,neighbors:h}=n.payload;q=s,k=new Map;for(const b of c)k.set(b.id,b);if(!q)throw new Error("[MesherWorker] Atlas config is required but not provided");if(!q.atlasSize||!q.tileSize||!q.tiles)throw new Error("[MesherWorker] Invalid atlas config - missing required properties");const u=xt(o,h,t),C={type:"CHUNK_MESH",key:t,payload:u};self.postMessage(C,{transfer:[u.opaque.positions.buffer,u.opaque.normals.buffer,u.opaque.uvs.buffer,u.opaque.indices.buffer,u.opaque.colors.buffer,u.transparent.positions.buffer,u.transparent.normals.buffer,u.transparent.uvs.buffer,u.transparent.indices.buffer,u.transparent.colors.buffer]})}function xt(n,t,o){const[s,c,h]=o.split(","),u=parseInt(s,10)||0,C=parseInt(c,10)||0,b=parseInt(h,10)||0,F=new Int16Array(e.x*e.z);for(let r=0;r<e.z;r++)for(let i=0;i<e.x;i++){const p=r*e.x+i;let Z=!1;if(t?.posY)for(let f=0;f<e.y;f++){const U=t.posY.voxels[m(i,f,r)],I=k.get(U);if(I&&I.opaque){Z=!0;break}}if(Z){F[p]=e.y+1;continue}let Y=-1;for(let f=e.y-1;f>=0;f--){const U=n.voxels[m(i,f,r)],I=k.get(U);if(I&&I.opaque){Y=f;break}}F[p]=Y+1}const A=[],M=[],d=[],K=[],N=[];let _=0;const D=[],J=[],Q=[],$=[],j=[];let g=0;for(let r=0;r<e.y;r++)for(let i=0;i<e.z;i++)for(let p=0;p<e.x;p++){const Z=m(p,r,i),Y=n.voxels[Z];if(Y===0)continue;const f=k.get(Y);if(!f)continue;const U=u*e.x+p,I=C*e.y+r,L=b*e.z+i,E=i*e.x+p,O=r>=F[E]?1:.7,V=f.name==="grass"||f.name==="wood"?0:vt(U,I,L),z=yt(U,I,L);for(const S of pt){if(f.name==="water"&&S.name!=="top")continue;const T=p+S.dir[0],X=r+S.dir[1],R=i+S.dir[2];let B=!1;if(T<0||T>=e.x||X<0||X>=e.y||R<0||R>=e.z){let w=!1;if(t){if(T===-1&&t.negX){const v=e.x-1,l=m(v,r,i),x=t.negX.voxels[l],a=k.get(x);w=!!(a&&a.opaque)}else if(T===e.x&&t.posX){const l=m(0,r,i),x=t.posX.voxels[l],a=k.get(x);w=!!(a&&a.opaque)}else if(R===-1&&t.negZ){const v=e.z-1,l=m(p,r,v),x=t.negZ.voxels[l],a=k.get(x);w=!!(a&&a.opaque)}else if(R===e.z&&t.posZ){const l=m(p,r,0),x=t.posZ.voxels[l],a=k.get(x);w=!!(a&&a.opaque)}else if(X===-1&&t.negY){const v=e.y-1,l=m(p,v,i),x=t.negY.voxels[l],a=k.get(x);w=!!(a&&a.opaque)}else if(X===e.y&&t.posY){const l=m(p,0,i),x=t.posY.voxels[l],a=k.get(x);w=!!(a&&a.opaque)}}B=!w}else{const w=m(T,X,R),v=n.voxels[w],l=k.get(v);B=!l||!l.opaque}B&&(!!f.opaque?(st(p,r,i,S,f,A,M,d,K,N,_,n,t,O,V,z),_+=4):(st(p,r,i,S,f,D,J,Q,$,j,g,n,t,1,0,1),g+=4))}}return{opaque:{positions:new Float32Array(A),normals:new Float32Array(M),uvs:new Float32Array(d),colors:new Float32Array(K),indices:new Uint32Array(N)},transparent:{positions:new Float32Array(D),normals:new Float32Array(J),uvs:new Float32Array(Q),colors:new Float32Array($),indices:new Uint32Array(j)}}}function st(n,t,o,s,c,h,u,C,b,F,A,M,d,K,N,_){const[D,J,Q]=s.normal,[$,j]=ht(c,s.name);let g;switch(s.name){case"front":g=[[n,t,o+1],[n+1,t,o+1],[n+1,t+1,o+1],[n,t+1,o+1]];break;case"back":g=[[n+1,t,o],[n,t,o],[n,t+1,o],[n+1,t+1,o]];break;case"right":g=[[n+1,t,o+1],[n+1,t,o],[n+1,t+1,o],[n+1,t+1,o+1]];break;case"left":g=[[n,t,o],[n,t,o+1],[n,t+1,o+1],[n,t+1,o]];break;case"top":g=[[n,t+1,o+1],[n+1,t+1,o+1],[n+1,t+1,o],[n,t+1,o]];break;case"bottom":g=[[n,t,o],[n+1,t,o],[n+1,t,o+1],[n,t,o+1]];break;default:return}for(const[y,W,ot]of g)h.push(y,W,ot);for(let y=0;y<4;y++)u.push(D,J,Q);if(!q)throw new Error("[MesherWorker] Atlas config required for UV calculation");const r=1/q.atlasSize,i=1,p=.5/(q.atlasSize*q.tileSize),Z=.5/(1*q.tileSize),Y=$*r+p,f=j*i+Z,U=Y+r-2*p,I=f+i-2*Z,L=[Y,I],E=[U,I],O=[U,f],V=[Y,f];let z=[L,E,O,V];const S=N&3;S===1?z=[V,L,E,O]:S===2?z=[O,V,L,E]:S===3&&(z=[E,O,V,L]);for(const y of z)C.push(y[0],y[1]);const T=!!c.solid&&c.name!=="water",X=[1,.8,.6,.45],R=n+s.dir[0],B=t+s.dir[1],w=o+s.dir[2],v=s.name==="front"||s.name==="back"||s.name==="top"||s.name==="bottom"?(s.name==="top"||s.name==="bottom",0):2,l=s.name==="top"||s.name==="bottom"?2:(s.name==="front"||s.name==="back",1),x=(y,W)=>y[W],a=[R,B,w];for(let y=0;y<4;y++){const W=g[y][0],ot=g[y][1],kt=g[y][2],ct=[W,ot,kt],rt=x(ct,v)>x(a,v)?1:-1,it=x(ct,l)>x(a,l)?1:-1,G=[...a];G[v]+=rt;const P=[...a];P[l]+=it;const H=[...a];H[v]+=rt,H[l]+=it;let ft=1;if(T){const lt=nt(G[0],G[1],G[2],M,d),ut=nt(P[0],P[1],P[2],M,d),gt=nt(H[0],H[1],H[2],M,d);let tt=0;lt&&tt++,ut&&tt++,gt&&!(lt&&ut)&&tt++,ft=X[tt]}const et=ft*K*(T?_:1);b.push(et,et,et)}F.push(A,A+1,A+2,A,A+2,A+3)}function ht(n,t){if(!q)throw new Error("[MesherWorker] Atlas config required for UV lookup");let o;switch(t){case"top":o=n.faces.top||n.faces.all||"air";break;case"bottom":o=n.faces.bottom||n.faces.all||"air";break;case"front":case"back":case"left":case"right":o=n.faces.side||n.faces.all||"air";break;default:o=n.faces.all||"air";break}const s=q.tiles[o];return s||(console.warn(`[MesherWorker] Tile key '${o}' not found in atlas config, using fallback`),[0,0])}function Mt(n,t,o){return n>=0&&n<e.x&&t>=0&&t<e.y&&o>=0&&o<e.z}function nt(n,t,o,s,c){let h=-1;if(Mt(n,t,o))h=s.voxels[m(n,t,o)];else{const C=n<0?-1:n>=e.x?1:0,b=t<0?-1:t>=e.y?1:0,F=o<0?-1:o>=e.z?1:0;if(Math.abs(C)+Math.abs(b)+Math.abs(F)>1)return!1;if(C===-1&&c?.negX){const M=e.x-1,d=m(M,Math.max(0,Math.min(e.y-1,t)),Math.max(0,Math.min(e.z-1,o)));h=c.negX.voxels[d]}else if(C===1&&c?.posX){const d=m(0,Math.max(0,Math.min(e.y-1,t)),Math.max(0,Math.min(e.z-1,o)));h=c.posX.voxels[d]}else if(F===-1&&c?.negZ){const M=e.z-1,d=m(Math.max(0,Math.min(e.x-1,n)),Math.max(0,Math.min(e.y-1,t)),M);h=c.negZ.voxels[d]}else if(F===1&&c?.posZ){const d=m(Math.max(0,Math.min(e.x-1,n)),Math.max(0,Math.min(e.y-1,t)),0);h=c.posZ.voxels[d]}else if(b===-1&&c?.negY){const M=e.y-1,d=m(Math.max(0,Math.min(e.x-1,n)),M,Math.max(0,Math.min(e.z-1,o)));h=c.negY.voxels[d]}else if(b===1&&c?.posY){const d=m(Math.max(0,Math.min(e.x-1,n)),0,Math.max(0,Math.min(e.z-1,o)));h=c.posY.voxels[d]}else return!1}const u=h>=0?k.get(h):void 0;return!!(u&&u.opaque)}function at(n,t,o){let s=n*374761393^t*668265263^o*2147483647;return s=(s^s>>>13)*1274126177,(s^s>>>16)>>>0}function vt(n,t,o){return at(n,t,o)&3}function yt(n,t,o){return 1+((at(n+11,t+121,o+211)&65535)/65535*.06-.03)}})();
